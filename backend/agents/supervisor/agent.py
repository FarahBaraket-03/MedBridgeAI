"""
MedBridge AI — AGENT 1: Supervisor Agent (The Router)
======================================================
Routes incoming queries to the appropriate agent(s) based on intent.
Uses regex-based classification with optional LLM enhancement.

INPUT:  Natural language query
OUTPUT: Execution plan with identified agents and workflow steps
"""

import re
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional


class IntentType(str, Enum):
    """Recognized query intents."""
    COUNT = "count"
    AGGREGATE = "aggregate"
    FACILITY_LOOKUP = "facility_lookup"
    SERVICE_SEARCH = "service_search"
    SPECIALTY_SEARCH = "specialty_search"
    ANOMALY_DETECTION = "anomaly_detection"
    VALIDATION = "validation"
    DISTANCE_QUERY = "distance_query"
    COVERAGE_GAP = "coverage_gap"
    MEDICAL_DESERT = "medical_desert"
    COMPARISON = "comparison"
    SINGLE_POINT_FAILURE = "single_point_failure"
    PLANNING = "planning"
    GENERAL = "general"


class AgentType(str, Enum):
    """Available sub-agents."""
    GENIE = "genie"
    VECTOR_SEARCH = "vector_search"
    MEDICAL_REASONING = "medical_reasoning"
    GEOSPATIAL = "geospatial"
    PLANNING = "planning"


@dataclass
class TraceStep:
    """A single step in the agent execution trace (for citations)."""
    agent: str
    action: str
    input_data: Any = None
    output_summary: str = ""
    duration_ms: float = 0.0
    citations: List[Dict] = field(default_factory=list)


@dataclass
class ExecutionPlan:
    """The plan generated by the Supervisor for a given query."""
    query: str
    primary_intent: str
    required_agents: List[str]
    execution_flow: str  # "sequential" or "parallel"
    steps: List[str]
    confidence: float = 1.0


# ── Intent classification patterns ──────────────────────────────────────────

INTENT_PATTERNS = {
    IntentType.COUNT: [
        r"how many", r"count", r"number of", r"total\b",
    ],
    IntentType.AGGREGATE: [
        r"which region.*most", r"most .*(hospital|clinic|facilit)",
        r"distribution", r"breakdown", r"aggregate", r"by region",
        r"per (region|city|district)", r"group by",
    ],
    IntentType.ANOMALY_DETECTION: [
        r"anomal", r"unusual", r"suspicious", r"ratio",
        r"bed.to.doctor", r"unrealistic", r"implausible",
        r"shouldn.t move together", r"correlation.*charact",
        r"high.*procedure.*breadth.*minimal",
    ],
    IntentType.VALIDATION: [
        r"claim.*but.*lack", r"valid", r"verify",
        r"really.*offer", r"actually.*have",
        r"claiming.*without", r"lack.*equipment",
        r"infrastruc.*match", r"features.*don.t match",
        r"subspecialty.*claim.*supporting",
        r"suspicious.*claim", r"suspicious.*capabilit",
        r"can.*really", r"legitimate",
    ],
    IntentType.DISTANCE_QUERY: [
        r"within\s+\d+\s*km", r"nearest", r"closest",
        r"distance", r"travel time", r"how far",
        r"\bnear\b", r"nearby", r"proximit", r"close to",
    ],
    IntentType.COVERAGE_GAP: [
        r"cold spot", r"gap", r"desert",
        r"no.*facilit.*in", r"absent",
        r"where.*no\s+(hospital|clinic|facilit|organization)",
        r"underserved", r"lack.*access",
        r"lack.*(care|service|health|emergenc)",
        r"without.*(access|care|coverage)",
    ],
    IntentType.MEDICAL_DESERT: [
        r"medical desert", r"healthcare desert",
        r"no.*coverage", r"coverage gap",
        r"geographic.*gap", r"largest.*gap",
    ],
    IntentType.SINGLE_POINT_FAILURE: [
        r"single point", r"few facilit", r"depend.*on.*few",
        r"rare.*special", r"only.*one.*facilit",
        r"oversupply.*scarci", r"concentration.*vs",
    ],
    IntentType.FACILITY_LOOKUP: [
        r"what.*services.*does", r"what.*does.*offer",
        r"tell me about", r"information.*about",
        r"details.*(?:for|about|on)",
    ],
    IntentType.SERVICE_SEARCH: [
        r"(?:facilit|clinic|hospital).*(?:that|which).*(?:do|offer|perform|provide|handle|have|can)",
        r"(?:where|who).*(?:can|does).*(?:perform|offer|do|handle|treat)",
        r"are there.*(?:clinic|hospital|facilit)",
        r"(?:find|list|show|which).*(?:facilit|clinic|hospital).*(?:with|offer|provid|can|for)",
        r"(?:facilit|clinic|hospital).*(?:for|with).*(?:patient|service|care|treatment)",
        r"can handle",
    ],
    IntentType.SPECIALTY_SEARCH: [
        r"(?:specialt|specialist|subspecialt)",
        r"workforce.*for", r"where.*practicing",
        r"visiting.*vs.*permanent",
    ],
    IntentType.COMPARISON: [
        r"compar", r"vs\b", r"versus", r"differ",
        r"urban.*rural", r"between.*region",
    ],
    IntentType.PLANNING: [
        r"plan\b", r"deploy", r"route.*patient", r"emergenc.*rout",
        r"specialist.*rotat", r"equipment.*distribut", r"where.*build",
        r"new.*facilit", r"capacity.*plan", r"scenario", r"mobile.*unit",
        r"visiting.*doctor", r"bottleneck", r"optimal.*location",
        r"where.*should.*(?:we|you)", r"recommend",
    ],
}

# ── Agent routing table ──────────────────────────────────────────────────────

ROUTING_TABLE: Dict[IntentType, Dict] = {
    IntentType.COUNT: {
        "agents": [AgentType.GENIE],
        "flow": "single",
    },
    IntentType.AGGREGATE: {
        "agents": [AgentType.GENIE],
        "flow": "single",
    },
    IntentType.ANOMALY_DETECTION: {
        "agents": [AgentType.GENIE, AgentType.MEDICAL_REASONING],
        "flow": "sequential",
    },
    IntentType.VALIDATION: {
        "agents": [AgentType.VECTOR_SEARCH, AgentType.MEDICAL_REASONING],
        "flow": "sequential",
    },
    IntentType.DISTANCE_QUERY: {
        "agents": [AgentType.GEOSPATIAL],
        "flow": "single",
    },
    IntentType.COVERAGE_GAP: {
        "agents": [AgentType.GEOSPATIAL, AgentType.MEDICAL_REASONING],
        "flow": "sequential",
    },
    IntentType.MEDICAL_DESERT: {
        "agents": [AgentType.GEOSPATIAL, AgentType.MEDICAL_REASONING],
        "flow": "sequential",
    },
    IntentType.SINGLE_POINT_FAILURE: {
        "agents": [AgentType.GENIE, AgentType.MEDICAL_REASONING],
        "flow": "sequential",
    },
    IntentType.FACILITY_LOOKUP: {
        "agents": [AgentType.VECTOR_SEARCH],
        "flow": "single",
    },
    IntentType.SERVICE_SEARCH: {
        "agents": [AgentType.VECTOR_SEARCH, AgentType.GENIE],
        "flow": "sequential",
    },
    IntentType.SPECIALTY_SEARCH: {
        "agents": [AgentType.VECTOR_SEARCH],
        "flow": "single",
    },
    IntentType.COMPARISON: {
        "agents": [AgentType.GENIE, AgentType.GEOSPATIAL],
        "flow": "parallel",
    },
    IntentType.PLANNING: {
        "agents": [AgentType.PLANNING],
        "flow": "single",
    },
    IntentType.GENERAL: {
        "agents": [AgentType.VECTOR_SEARCH, AgentType.GENIE],
        "flow": "parallel",
    },
}


class SupervisorAgent:
    """
    Intent classification → agent routing → execution plan generation.
    """

    def classify_intent(self, query: str) -> IntentType:
        """Classify query intent using regex pattern matching."""
        query_lower = query.lower()
        scores: Dict[IntentType, int] = {}

        for intent, patterns in INTENT_PATTERNS.items():
            score = sum(1 for p in patterns if re.search(p, query_lower))
            if score > 0:
                scores[intent] = score

        if not scores:
            return IntentType.GENERAL

        # Return highest-scoring intent
        return max(scores, key=scores.get)

    def create_execution_plan(self, query: str) -> ExecutionPlan:
        """Generate a full execution plan for the query."""
        intent = self.classify_intent(query)
        routing = ROUTING_TABLE.get(intent, ROUTING_TABLE[IntentType.GENERAL])

        agents = [a.value for a in routing["agents"]]
        flow = routing["flow"]

        steps = []
        for i, agent_name in enumerate(agents, 1):
            step_desc = self._describe_step(agent_name, query, intent)
            steps.append(f"Step {i} [{agent_name}]: {step_desc}")

        return ExecutionPlan(
            query=query,
            primary_intent=intent.value,
            required_agents=agents,
            execution_flow=flow,
            steps=steps,
        )

    def _describe_step(self, agent_name: str, query: str, intent: IntentType) -> str:
        """Generate a human-readable description of what this agent will do."""
        descriptions = {
            "genie": {
                IntentType.COUNT: "Count matching facilities in structured data",
                IntentType.AGGREGATE: "Aggregate data by region/type/specialty",
                IntentType.ANOMALY_DETECTION: "Retrieve structured data for anomaly analysis",
                IntentType.SINGLE_POINT_FAILURE: "Identify rare specialties/procedures",
            },
            "vector_search": {
                IntentType.FACILITY_LOOKUP: "Semantic search for facility information",
                IntentType.SERVICE_SEARCH: "Search unstructured text for matching services",
                IntentType.SPECIALTY_SEARCH: "Find facilities with matching specialties",
                IntentType.VALIDATION: "Find facilities claiming specific capabilities",
            },
            "medical_reasoning": {
                IntentType.ANOMALY_DETECTION: "Detect statistical and logical anomalies",
                IntentType.VALIDATION: "Validate claims against medical constraints",
                IntentType.COVERAGE_GAP: "Analyze coverage sufficiency and identify gaps",
                IntentType.SINGLE_POINT_FAILURE: "Assess system resilience and risks",
            },
            "geospatial": {
                IntentType.DISTANCE_QUERY: "Calculate distances and find nearby facilities",
                IntentType.COVERAGE_GAP: "Map geographic coverage gaps",
                IntentType.MEDICAL_DESERT: "Identify medical desert regions",
                IntentType.COMPARISON: "Compare geographic distribution patterns",
            },
            "planning": {
                IntentType.PLANNING: "Generate actionable deployment/routing plan",
            },
        }

        agent_descs = descriptions.get(agent_name, {})
        return agent_descs.get(intent, f"Process query via {agent_name}")

    def to_dict(self, plan: ExecutionPlan) -> Dict:
        """Serialize the execution plan to a dict for API responses."""
        return {
            "query": plan.query,
            "primary_intent": plan.primary_intent,
            "required_agents": plan.required_agents,
            "execution_flow": plan.execution_flow,
            "steps": plan.steps,
            "confidence": plan.confidence,
        }
